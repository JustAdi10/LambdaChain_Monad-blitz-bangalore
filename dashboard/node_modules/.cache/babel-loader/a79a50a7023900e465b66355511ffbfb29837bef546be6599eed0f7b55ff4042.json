{"ast":null,"code":"import { ethers } from 'ethers';\nimport MetricsService from './MetricsService';\n// Smart Contract Configuration\nconst CONFIG = {\n  rpcUrl: 'https://testnet-rpc.monad.xyz',\n  registryAddress: '0x4142d9Ad70f87c359260e6dC41340af5823BC888',\n  privateKey: process.env.REACT_APP_PRIVATE_KEY || '0xb480778fb8d22695cd5bc45337fbb300e784bd237c8a6f21a852cc41b98a081b',\n  gasPrice: ethers.parseUnits('50', 'gwei')\n};\n\n// Contract ABI\nconst FUNCTION_REGISTRY_ABI = ['function registerFunction(string calldata name, string calldata description, bytes32 wasmHash, uint256 gasLimit, string calldata runtime) external returns (uint256 functionId)', 'function addTrigger(uint256 functionId, uint8 triggerType, bytes calldata triggerData) external returns (uint256 triggerId)', 'function fireTrigger(uint256 triggerId, bytes calldata contextData) external', 'function nextFunctionId() external view returns (uint256)', 'function nextTriggerId() external view returns (uint256)', 'event FunctionRegistered(uint256 indexed functionId, address indexed owner, string name, bytes32 wasmHash)', 'event TriggerAdded(uint256 indexed triggerId, uint256 indexed functionId, uint8 triggerType)', 'event TriggerFired(uint256 indexed triggerId, uint256 indexed functionId, bytes contextData)'];\n\n// Trigger Types (matching smart contract enum)\nconst TriggerType = {\n  HTTP_WEBHOOK: 0,\n  ON_CHAIN_EVENT: 1,\n  PRICE_THRESHOLD: 2,\n  TIME_BASED: 3,\n  CUSTOM: 4\n};\nclass DeploymentService {\n  constructor() {\n    this.provider = void 0;\n    this.wallet = void 0;\n    this.registry = void 0;\n    this.provider = new ethers.JsonRpcProvider(CONFIG.rpcUrl);\n    this.wallet = new ethers.Wallet(CONFIG.privateKey, this.provider);\n    this.registry = new ethers.Contract(CONFIG.registryAddress, FUNCTION_REGISTRY_ABI, this.wallet);\n  }\n\n  // Deploy a complete function with trigger\n  async deployFunction(functionData) {\n    try {\n      console.log('Starting function deployment:', functionData.name);\n\n      // Step 1: Compile code to WASM hash (mock for demo)\n      const wasmHash = await this.compileToWasm(functionData.code, functionData.runtime);\n\n      // Step 2: Register function on-chain\n      const functionResult = await this.registerFunction(functionData, wasmHash);\n      if (!functionResult.success || !functionResult.functionId) {\n        return functionResult;\n      }\n\n      // Step 3: Add trigger\n      const triggerResult = await this.addTrigger(functionResult.functionId, functionData.triggerType, functionData.triggerConfig);\n      if (!triggerResult.success) {\n        return {\n          success: false,\n          error: `Function registered but trigger failed: ${triggerResult.error}`\n        };\n      }\n\n      // Step 4: Store function metadata for orchestrator\n      await this.storeFunctionMetadata(functionResult.functionId, functionData);\n      return {\n        success: true,\n        functionId: functionResult.functionId,\n        triggerId: triggerResult.triggerId,\n        txHash: functionResult.txHash\n      };\n    } catch (error) {\n      console.error('Deployment failed:', error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown deployment error'\n      };\n    }\n  }\n\n  // Register function on blockchain\n  async registerFunction(functionData, wasmHash) {\n    try {\n      const startTime = Date.now();\n      console.log('Registering function on blockchain...');\n      const tx = await this.registry.registerFunction(functionData.name, functionData.description, ethers.keccak256(ethers.toUtf8Bytes(wasmHash)), functionData.gasLimit, functionData.runtime, {\n        gasLimit: 300000,\n        gasPrice: CONFIG.gasPrice\n      });\n      console.log('Transaction sent:', tx.hash);\n      const receipt = await tx.wait();\n\n      // Record metrics\n      const executionTime = Date.now() - startTime;\n      MetricsService.recordFunctionRegistration(receipt.gasUsed, executionTime);\n\n      // Extract function ID from events\n      const log = receipt.logs.find(log => {\n        try {\n          const parsed = this.registry.interface.parseLog(log);\n          return parsed && parsed.name === 'FunctionRegistered';\n        } catch {\n          return false;\n        }\n      });\n      if (log) {\n        const parsed = this.registry.interface.parseLog(log);\n        const functionId = Number(parsed.args[0]);\n        console.log('Function registered with ID:', functionId);\n        return {\n          success: true,\n          functionId,\n          txHash: tx.hash\n        };\n      }\n      return {\n        success: false,\n        error: 'Function registration event not found'\n      };\n    } catch (error) {\n      console.error('Function registration failed:', error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Registration failed'\n      };\n    }\n  }\n\n  // Add trigger for function\n  async addTrigger(functionId, triggerType, triggerConfig) {\n    try {\n      const startTime = Date.now();\n      console.log('Adding trigger for function:', functionId);\n\n      // Map trigger type string to enum\n      const triggerTypeEnum = this.mapTriggerType(triggerType);\n\n      // Encode trigger data\n      const triggerData = this.encodeTriggerData(triggerType, triggerConfig);\n      const tx = await this.registry.addTrigger(functionId, triggerTypeEnum, triggerData, {\n        gasLimit: 200000,\n        gasPrice: CONFIG.gasPrice\n      });\n      console.log('Trigger transaction sent:', tx.hash);\n      const receipt = await tx.wait();\n\n      // Record metrics\n      const executionTime = Date.now() - startTime;\n      MetricsService.recordTriggerCreation(receipt.gasUsed, executionTime);\n\n      // Extract trigger ID from events\n      const log = receipt.logs.find(log => {\n        try {\n          const parsed = this.registry.interface.parseLog(log);\n          return parsed && parsed.name === 'TriggerAdded';\n        } catch {\n          return false;\n        }\n      });\n      if (log) {\n        const parsed = this.registry.interface.parseLog(log);\n        const triggerId = Number(parsed.args[0]);\n        console.log('Trigger added with ID:', triggerId);\n        return {\n          success: true,\n          triggerId,\n          txHash: tx.hash\n        };\n      }\n      return {\n        success: false,\n        error: 'Trigger creation event not found'\n      };\n    } catch (error) {\n      console.error('Trigger creation failed:', error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Trigger creation failed'\n      };\n    }\n  }\n\n  // Compile code to WASM (mock implementation for demo)\n  async compileToWasm(code, runtime) {\n    // In production, this would:\n    // 1. Send code to compilation service\n    // 2. Compile to WASM\n    // 3. Upload to IPFS\n    // 4. Return IPFS hash\n\n    // For demo, create a deterministic hash based on code\n    const hash = ethers.keccak256(ethers.toUtf8Bytes(code + runtime));\n    const mockIpfsHash = `Qm${hash.slice(2, 34)}`;\n    console.log('Mock WASM compilation completed:', mockIpfsHash);\n    return mockIpfsHash;\n  }\n\n  // Map trigger type string to contract enum\n  mapTriggerType(triggerType) {\n    switch (triggerType) {\n      case 'webhook':\n      case 'http-webhook':\n        return TriggerType.HTTP_WEBHOOK;\n      case 'on-chain-event':\n        return TriggerType.ON_CHAIN_EVENT;\n      case 'price-threshold':\n        return TriggerType.PRICE_THRESHOLD;\n      case 'time-based':\n        return TriggerType.TIME_BASED;\n      default:\n        return TriggerType.CUSTOM;\n    }\n  }\n\n  // Encode trigger data for smart contract\n  encodeTriggerData(triggerType, config) {\n    var _config$threshold;\n    switch (triggerType) {\n      case 'price-threshold':\n        return ethers.AbiCoder.defaultAbiCoder().encode(['string', 'uint256'], [config.token || 'ETH', ethers.parseEther(((_config$threshold = config.threshold) === null || _config$threshold === void 0 ? void 0 : _config$threshold.toString()) || '1')]);\n      case 'on-chain-event':\n        return ethers.AbiCoder.defaultAbiCoder().encode(['address', 'bytes32'], [config.contractAddress || ethers.ZeroAddress, config.eventSignature || ethers.ZeroHash]);\n      case 'webhook':\n        return ethers.AbiCoder.defaultAbiCoder().encode(['string'], [config.url || '']);\n      case 'time-based':\n        return ethers.AbiCoder.defaultAbiCoder().encode(['uint256'], [config.interval || 3600] // Default 1 hour\n        );\n      default:\n        return ethers.AbiCoder.defaultAbiCoder().encode(['string'], [JSON.stringify(config)]);\n    }\n  }\n\n  // Store function metadata for orchestrator\n  async storeFunctionMetadata(functionId, functionData) {\n    // In production, this would store in a database or IPFS\n    // For demo, we'll store in localStorage\n    const metadata = {\n      functionId,\n      name: functionData.name,\n      description: functionData.description,\n      code: functionData.code,\n      runtime: functionData.runtime,\n      triggerType: functionData.triggerType,\n      triggerConfig: functionData.triggerConfig,\n      webhookUrl: functionData.webhookUrl,\n      deployedAt: new Date().toISOString()\n    };\n    const existingFunctions = JSON.parse(localStorage.getItem('monadFaasFunctions') || '[]');\n    existingFunctions.push(metadata);\n    localStorage.setItem('monadFaasFunctions', JSON.stringify(existingFunctions));\n    console.log('Function metadata stored:', metadata);\n  }\n\n  // Get deployed functions\n  getDeployedFunctions() {\n    return JSON.parse(localStorage.getItem('monadFaasFunctions') || '[]');\n  }\n\n  // Test function execution (simulate trigger)\n  async testFunction(functionId, triggerId, testData = {}) {\n    try {\n      console.log('Testing function execution:', {\n        functionId,\n        triggerId\n      });\n      const contextData = ethers.AbiCoder.defaultAbiCoder().encode(['string', 'uint256', 'string'], ['test', Math.floor(Date.now() / 1000), JSON.stringify(testData)]);\n      const tx = await this.registry.fireTrigger(triggerId, contextData, {\n        gasLimit: 150000,\n        gasPrice: CONFIG.gasPrice\n      });\n      const receipt = await tx.wait();\n\n      // Record execution metrics\n      MetricsService.recordExecution({\n        functionId,\n        triggerId,\n        txHash: tx.hash,\n        timestamp: Date.now(),\n        gasUsed: receipt.gasUsed,\n        success: receipt.status === 1,\n        executionTime: 1000 // Mock execution time\n      });\n      return {\n        success: true,\n        txHash: tx.hash,\n        gasUsed: receipt.gasUsed.toString()\n      };\n    } catch (error) {\n      console.error('Function test failed:', error);\n\n      // Record failed execution\n      MetricsService.recordExecution({\n        functionId,\n        triggerId,\n        txHash: '',\n        timestamp: Date.now(),\n        gasUsed: BigInt(0),\n        success: false,\n        executionTime: 0,\n        errorMessage: error instanceof Error ? error.message : 'Unknown error'\n      });\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Test execution failed'\n      };\n    }\n  }\n}\nconst deploymentServiceInstance = new DeploymentService();\nexport default deploymentServiceInstance;","map":{"version":3,"names":["ethers","MetricsService","CONFIG","rpcUrl","registryAddress","privateKey","process","env","REACT_APP_PRIVATE_KEY","gasPrice","parseUnits","FUNCTION_REGISTRY_ABI","TriggerType","HTTP_WEBHOOK","ON_CHAIN_EVENT","PRICE_THRESHOLD","TIME_BASED","CUSTOM","DeploymentService","constructor","provider","wallet","registry","JsonRpcProvider","Wallet","Contract","deployFunction","functionData","console","log","name","wasmHash","compileToWasm","code","runtime","functionResult","registerFunction","success","functionId","triggerResult","addTrigger","triggerType","triggerConfig","error","storeFunctionMetadata","triggerId","txHash","Error","message","startTime","Date","now","tx","description","keccak256","toUtf8Bytes","gasLimit","hash","receipt","wait","executionTime","recordFunctionRegistration","gasUsed","logs","find","parsed","interface","parseLog","Number","args","triggerTypeEnum","mapTriggerType","triggerData","encodeTriggerData","recordTriggerCreation","mockIpfsHash","slice","config","_config$threshold","AbiCoder","defaultAbiCoder","encode","token","parseEther","threshold","toString","contractAddress","ZeroAddress","eventSignature","ZeroHash","url","interval","JSON","stringify","metadata","webhookUrl","deployedAt","toISOString","existingFunctions","parse","localStorage","getItem","push","setItem","getDeployedFunctions","testFunction","testData","contextData","Math","floor","fireTrigger","recordExecution","timestamp","status","BigInt","errorMessage","deploymentServiceInstance"],"sources":["/home/aditya/Desktop/Repos/monad-blitz-bangalore/dashboard/src/services/DeploymentService.ts"],"sourcesContent":["import { ethers } from 'ethers';\nimport MetricsService from './MetricsService';\n\nexport interface FunctionDeploymentData {\n  name: string;\n  description: string;\n  code: string;\n  runtime: 'javascript' | 'python' | 'solidity';\n  triggerType: string;\n  triggerConfig: any;\n  webhookUrl?: string;\n  gasLimit: number;\n}\n\nexport interface DeploymentResult {\n  success: boolean;\n  functionId?: number;\n  triggerId?: number;\n  txHash?: string;\n  error?: string;\n}\n\n// Smart Contract Configuration\nconst CONFIG = {\n  rpcUrl: 'https://testnet-rpc.monad.xyz',\n  registryAddress: '0x4142d9Ad70f87c359260e6dC41340af5823BC888',\n  privateKey: process.env.REACT_APP_PRIVATE_KEY || '0xb480778fb8d22695cd5bc45337fbb300e784bd237c8a6f21a852cc41b98a081b',\n  gasPrice: ethers.parseUnits('50', 'gwei'),\n};\n\n// Contract ABI\nconst FUNCTION_REGISTRY_ABI = [\n  'function registerFunction(string calldata name, string calldata description, bytes32 wasmHash, uint256 gasLimit, string calldata runtime) external returns (uint256 functionId)',\n  'function addTrigger(uint256 functionId, uint8 triggerType, bytes calldata triggerData) external returns (uint256 triggerId)',\n  'function fireTrigger(uint256 triggerId, bytes calldata contextData) external',\n  'function nextFunctionId() external view returns (uint256)',\n  'function nextTriggerId() external view returns (uint256)',\n  'event FunctionRegistered(uint256 indexed functionId, address indexed owner, string name, bytes32 wasmHash)',\n  'event TriggerAdded(uint256 indexed triggerId, uint256 indexed functionId, uint8 triggerType)',\n  'event TriggerFired(uint256 indexed triggerId, uint256 indexed functionId, bytes contextData)'\n];\n\n// Trigger Types (matching smart contract enum)\nconst TriggerType = {\n  HTTP_WEBHOOK: 0,\n  ON_CHAIN_EVENT: 1,\n  PRICE_THRESHOLD: 2,\n  TIME_BASED: 3,\n  CUSTOM: 4\n};\n\nclass DeploymentService {\n  private provider: ethers.JsonRpcProvider;\n  private wallet: ethers.Wallet;\n  private registry: ethers.Contract;\n\n  constructor() {\n    this.provider = new ethers.JsonRpcProvider(CONFIG.rpcUrl);\n    this.wallet = new ethers.Wallet(CONFIG.privateKey, this.provider);\n    this.registry = new ethers.Contract(CONFIG.registryAddress, FUNCTION_REGISTRY_ABI, this.wallet);\n  }\n\n  // Deploy a complete function with trigger\n  async deployFunction(functionData: FunctionDeploymentData): Promise<DeploymentResult> {\n    try {\n      console.log('Starting function deployment:', functionData.name);\n\n      // Step 1: Compile code to WASM hash (mock for demo)\n      const wasmHash = await this.compileToWasm(functionData.code, functionData.runtime);\n      \n      // Step 2: Register function on-chain\n      const functionResult = await this.registerFunction(functionData, wasmHash);\n      if (!functionResult.success || !functionResult.functionId) {\n        return functionResult;\n      }\n\n      // Step 3: Add trigger\n      const triggerResult = await this.addTrigger(\n        functionResult.functionId,\n        functionData.triggerType,\n        functionData.triggerConfig\n      );\n\n      if (!triggerResult.success) {\n        return {\n          success: false,\n          error: `Function registered but trigger failed: ${triggerResult.error}`\n        };\n      }\n\n      // Step 4: Store function metadata for orchestrator\n      await this.storeFunctionMetadata(functionResult.functionId, functionData);\n\n      return {\n        success: true,\n        functionId: functionResult.functionId,\n        triggerId: triggerResult.triggerId,\n        txHash: functionResult.txHash\n      };\n\n    } catch (error) {\n      console.error('Deployment failed:', error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown deployment error'\n      };\n    }\n  }\n\n  // Register function on blockchain\n  private async registerFunction(\n    functionData: FunctionDeploymentData, \n    wasmHash: string\n  ): Promise<DeploymentResult> {\n    try {\n      const startTime = Date.now();\n      \n      console.log('Registering function on blockchain...');\n      \n      const tx = await this.registry.registerFunction(\n        functionData.name,\n        functionData.description,\n        ethers.keccak256(ethers.toUtf8Bytes(wasmHash)),\n        functionData.gasLimit,\n        functionData.runtime,\n        {\n          gasLimit: 300000,\n          gasPrice: CONFIG.gasPrice\n        }\n      );\n\n      console.log('Transaction sent:', tx.hash);\n      const receipt = await tx.wait();\n      \n      // Record metrics\n      const executionTime = Date.now() - startTime;\n      MetricsService.recordFunctionRegistration(receipt.gasUsed, executionTime);\n\n      // Extract function ID from events\n      const log = receipt.logs.find((log: any) => {\n        try {\n          const parsed = this.registry.interface.parseLog(log);\n          return parsed && parsed.name === 'FunctionRegistered';\n        } catch {\n          return false;\n        }\n      });\n\n      if (log) {\n        const parsed = this.registry.interface.parseLog(log);\n        const functionId = Number(parsed!.args[0]);\n        \n        console.log('Function registered with ID:', functionId);\n        \n        return {\n          success: true,\n          functionId,\n          txHash: tx.hash\n        };\n      }\n\n      return {\n        success: false,\n        error: 'Function registration event not found'\n      };\n\n    } catch (error) {\n      console.error('Function registration failed:', error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Registration failed'\n      };\n    }\n  }\n\n  // Add trigger for function\n  private async addTrigger(\n    functionId: number,\n    triggerType: string,\n    triggerConfig: any\n  ): Promise<DeploymentResult> {\n    try {\n      const startTime = Date.now();\n      \n      console.log('Adding trigger for function:', functionId);\n\n      // Map trigger type string to enum\n      const triggerTypeEnum = this.mapTriggerType(triggerType);\n      \n      // Encode trigger data\n      const triggerData = this.encodeTriggerData(triggerType, triggerConfig);\n\n      const tx = await this.registry.addTrigger(\n        functionId,\n        triggerTypeEnum,\n        triggerData,\n        {\n          gasLimit: 200000,\n          gasPrice: CONFIG.gasPrice\n        }\n      );\n\n      console.log('Trigger transaction sent:', tx.hash);\n      const receipt = await tx.wait();\n      \n      // Record metrics\n      const executionTime = Date.now() - startTime;\n      MetricsService.recordTriggerCreation(receipt.gasUsed, executionTime);\n\n      // Extract trigger ID from events\n      const log = receipt.logs.find((log: any) => {\n        try {\n          const parsed = this.registry.interface.parseLog(log);\n          return parsed && parsed.name === 'TriggerAdded';\n        } catch {\n          return false;\n        }\n      });\n\n      if (log) {\n        const parsed = this.registry.interface.parseLog(log);\n        const triggerId = Number(parsed!.args[0]);\n        \n        console.log('Trigger added with ID:', triggerId);\n        \n        return {\n          success: true,\n          triggerId,\n          txHash: tx.hash\n        };\n      }\n\n      return {\n        success: false,\n        error: 'Trigger creation event not found'\n      };\n\n    } catch (error) {\n      console.error('Trigger creation failed:', error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Trigger creation failed'\n      };\n    }\n  }\n\n  // Compile code to WASM (mock implementation for demo)\n  private async compileToWasm(code: string, runtime: string): Promise<string> {\n    // In production, this would:\n    // 1. Send code to compilation service\n    // 2. Compile to WASM\n    // 3. Upload to IPFS\n    // 4. Return IPFS hash\n    \n    // For demo, create a deterministic hash based on code\n    const hash = ethers.keccak256(ethers.toUtf8Bytes(code + runtime));\n    const mockIpfsHash = `Qm${hash.slice(2, 34)}`;\n    \n    console.log('Mock WASM compilation completed:', mockIpfsHash);\n    return mockIpfsHash;\n  }\n\n  // Map trigger type string to contract enum\n  private mapTriggerType(triggerType: string): number {\n    switch (triggerType) {\n      case 'webhook':\n      case 'http-webhook':\n        return TriggerType.HTTP_WEBHOOK;\n      case 'on-chain-event':\n        return TriggerType.ON_CHAIN_EVENT;\n      case 'price-threshold':\n        return TriggerType.PRICE_THRESHOLD;\n      case 'time-based':\n        return TriggerType.TIME_BASED;\n      default:\n        return TriggerType.CUSTOM;\n    }\n  }\n\n  // Encode trigger data for smart contract\n  private encodeTriggerData(triggerType: string, config: any): string {\n    switch (triggerType) {\n      case 'price-threshold':\n        return ethers.AbiCoder.defaultAbiCoder().encode(\n          ['string', 'uint256'],\n          [config.token || 'ETH', ethers.parseEther(config.threshold?.toString() || '1')]\n        );\n      \n      case 'on-chain-event':\n        return ethers.AbiCoder.defaultAbiCoder().encode(\n          ['address', 'bytes32'],\n          [config.contractAddress || ethers.ZeroAddress, config.eventSignature || ethers.ZeroHash]\n        );\n      \n      case 'webhook':\n        return ethers.AbiCoder.defaultAbiCoder().encode(\n          ['string'],\n          [config.url || '']\n        );\n      \n      case 'time-based':\n        return ethers.AbiCoder.defaultAbiCoder().encode(\n          ['uint256'],\n          [config.interval || 3600] // Default 1 hour\n        );\n      \n      default:\n        return ethers.AbiCoder.defaultAbiCoder().encode(\n          ['string'],\n          [JSON.stringify(config)]\n        );\n    }\n  }\n\n  // Store function metadata for orchestrator\n  private async storeFunctionMetadata(functionId: number, functionData: FunctionDeploymentData) {\n    // In production, this would store in a database or IPFS\n    // For demo, we'll store in localStorage\n    const metadata = {\n      functionId,\n      name: functionData.name,\n      description: functionData.description,\n      code: functionData.code,\n      runtime: functionData.runtime,\n      triggerType: functionData.triggerType,\n      triggerConfig: functionData.triggerConfig,\n      webhookUrl: functionData.webhookUrl,\n      deployedAt: new Date().toISOString()\n    };\n\n    const existingFunctions = JSON.parse(localStorage.getItem('monadFaasFunctions') || '[]');\n    existingFunctions.push(metadata);\n    localStorage.setItem('monadFaasFunctions', JSON.stringify(existingFunctions));\n    \n    console.log('Function metadata stored:', metadata);\n  }\n\n  // Get deployed functions\n  getDeployedFunctions() {\n    return JSON.parse(localStorage.getItem('monadFaasFunctions') || '[]');\n  }\n\n  // Test function execution (simulate trigger)\n  async testFunction(functionId: number, triggerId: number, testData: any = {}) {\n    try {\n      console.log('Testing function execution:', { functionId, triggerId });\n\n      const contextData = ethers.AbiCoder.defaultAbiCoder().encode(\n        ['string', 'uint256', 'string'],\n        [\n          'test',\n          Math.floor(Date.now() / 1000),\n          JSON.stringify(testData)\n        ]\n      );\n\n      const tx = await this.registry.fireTrigger(triggerId, contextData, {\n        gasLimit: 150000,\n        gasPrice: CONFIG.gasPrice\n      });\n\n      const receipt = await tx.wait();\n      \n      // Record execution metrics\n      MetricsService.recordExecution({\n        functionId,\n        triggerId,\n        txHash: tx.hash,\n        timestamp: Date.now(),\n        gasUsed: receipt.gasUsed,\n        success: receipt.status === 1,\n        executionTime: 1000 // Mock execution time\n      });\n\n      return {\n        success: true,\n        txHash: tx.hash,\n        gasUsed: receipt.gasUsed.toString()\n      };\n\n    } catch (error) {\n      console.error('Function test failed:', error);\n      \n      // Record failed execution\n      MetricsService.recordExecution({\n        functionId,\n        triggerId,\n        txHash: '',\n        timestamp: Date.now(),\n        gasUsed: BigInt(0),\n        success: false,\n        executionTime: 0,\n        errorMessage: error instanceof Error ? error.message : 'Unknown error'\n      });\n\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Test execution failed'\n      };\n    }\n  }\n}\n\nconst deploymentServiceInstance = new DeploymentService();\nexport default deploymentServiceInstance;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}